import json
import numpy as np

# all filter data acquired from SVO Filter Profile Service
fmap = {
	'g': 'LSST_LSST.g_filter.dat',
	'r': 'LSST_LSST.r_filter.dat', 
	'DanishR': 'LaSilla_DFOSC.Bessel_R_filter.dat',
	'Gemini-Nr': 'Gemini_GMOS-N.r.dat',
	'HSTF814W': 'HST_ACS_WFC.F814W.dat',
	'VLTI': 'Paranal_FORS2.V.dat',
	'VLTR': 'Paranal_FORS2.R.dat',
	'VLTV': 'Paranal_FORS2.V.dat',
	'HST+ACSF606W': 'HST_ACS_WFC.F606W.dat',
	'HST+ACSF814W': 'HST_ACS_WFC_F814W.dat',
	'HST+WFPC2F606W': 'HST_WFPC2-WF.F606W.dat',
	#'HST+WFPC2F814W': 	
}

def get_obs_sources(path_to_GRB_json):
	'''
	Prints a list of dictionary keys generated by concatenating
	the observation['telescope']+observation['band'] strings for
	each observation in the photometry dictionary.

	path_to_GRB_json: string
	
			  directory path to GRBXXXXXX.json file, assumed
			  to be in a subdirectory at least 1 level below 
			  working directory
	'''

	data = json.load(open(path_to_GRB_json))
	photometry = data[path_to_GRB_json.split('/')[-1][:-5]]["photometry"]

	# create empty list to house instrument+band combinations
	all_filters = []

	# loop over all observations in the photometry dictionary
	for observation in photometry:
		try: all_filters.append(observation['telescope']+'.'+observation['instrument']+'.'+observation['band'])
		# sometimes the telescope is included with the instrument
		except KeyError: all_filters.append(observation['instrument']+'.'+observation['band'])

	# Return all observations, removing duplicate instrument+band combinations
	return np.unique(all_filters)








def redistribute_flux(filter_orig, filter_updt, ab_mag_orig, verbose=False):

	'''
	filter_orig: string
	path to original filter transmission data

	filter_updt: string
	path to overlapping filter transmission data

	ab_mag_orig: float
	magnitude measured using original filter

	verbose: bool
	if true, prints detailed information about the conversion
	'''

	import numpy as np
	from scipy.integrate import simps

	# Load the filter data
	wav1, filt1 = np.loadtxt(filter_orig, dtype='float', unpack=True)
	wav2, filt2 = np.loadtxt(filter_updt, dtype='float', unpack=True)

	# Identify the wavelength range the 2 filters share in common
	wav_low = np.max([np.min(wav1), np.min(wav2)])
	wav_upp = np.min([np.max(wav1), np.max(wav2)])
	if verbose: print('Wavelength range: %g to %g Angstroms' % ( wav_low, wav_upp ))

	# Restrict the filter data to the common shared wavelengths
	f1_wavs = np.where((wav1 > wav_low) & (wav1 < wav_upp))[0]
	f2_wavs = np.where((wav2 > wav_low) & (wav2 < wav_upp))[0]
	filt1 = filt1[f1_wavs, :]
	filt2 = filt2[f2_wavs, :]

	# Integrate filter transmission data to get transmission ratio
	# Simpson's rule integral takes arguments simpson(y, x)
	# We want f2/f1 since flux_f2 = f2/f1*flux_f1
	f1_intgrl = simps(filt1, wav1)
	f2_intgrl = simps(filt2, wav2)
	ratio = f2_intgrl/f1_intgrl
	if verbose: print('Flux ratio f2/f1: ', ratio)
	
	# Convert AB magnitude observation back to flux
	# Scale the flux by the integrated filter transmission ratio
	# Re-convert flux back to AB mag to get the observation in the new filter
	#flux = 10**((ab_mag_orig+48.6)/-2.5)
	flux, sigma_flux = mag_orig_to_flux(ab_mag_orig, sigma_mag_orig)
	flux *= ratio
	sigma_flux *= ratio
	#ab_mag_new = -2.5*np.log10(flux)-48.6
	ab_mag_new, sigma_mag_new = flux_to_mag_new(flux, sigma_flux)
	if verbose: print('New AB mag: ', ab_mag_new)

	return ab_mag_new, sigma_mag_new
	
def mag_orig_to_flux(mag_orig, sigma_mag_orig):

	# propagate uncertainty through mag_orig -> flux conversion	
	# sigma_flux = sqrt(flux**2 * (-1/2.5 * ln(10) * sigma_mag_orig)**2)

	flux = np.power(10, (mag_orig+48.6)/-2.5)
	variance_flux = flux**2*(-1/2.5*np.ln(10)*sigma_mag)**2
	sigma_flux = np.sqrt(variance_flux)
	return flux, sigma_flux
	
def flux_to_mag_new(flux, sigma_flux):
	
	# propagate uncertainty through flux -> new_mag conversion
	# sigma_mag_new = sqrt([-2.5 * sigma_flux/(flux * ln(10))]^2)

	mag_new = -2.5*np.log10(flux)-48.6
	variance_mag_new = np.power(-2.5 * sigma_flux/(flux * np.ln(10)), 2)
	sigma_mag_new = np.sqrt(variance_mag_new)
	return mag_new, sigma_mag_new	


# update_photometry needs to be automated, current implementation is bad, too user-error prone
# 1. loop over all photometry for a given event
# 2. convert EVERY SINGLE instrument+band combination into LSST/2MASS variants, as LSST g may not be the same as GTC+OSIRIS g when doing full transmission, not just filters (which may be similar, but instruments are not)
# 3. uncertainties:
#	a) if an observation has e_magnitude, propagate that appropriately
# 	b) if an observation has e_upper_magnitude and e_lower_magnitude, 
#	   propagate each and take the average
#	c) if observation is an upper limit, set e_magnitude to 0 for
#	   propagation, then set it to 5 mag for inference (large uncertainty)
# 4. update the photometry dictionaries with the new observations. loop over# each old observation, replacing it with all the new observations
# 5. for preparing PE, make sure to use EM_PE json parser to generate standardized representations of the data 


def update_photometry(dfile, times, f1, f2, old_obs, obs_idxs, new_band, old_band, instrument, telescope, delete_flags, convert_from_vega=False): 
	'''
	dfile: string
	path to GRB050709.json data file

	times: float
	observation time in MJD at which the *new observation* will be recorded
	
	f1: string
	path to the *original* filter transmission data

	f2: string
	path to the *new* filter transmission data

	old_obs: float
	old observation magnitude measurement

	new_band: string
	filter name of new band (i.e. grizyJHK, F814W, etc.)

	old_band: string
	filter name of old band (i.e. grizyJHK, F814W, etc.)

	instrument: string
	name of instrument which houses the *new* filter

	telescope: string
	name of telescope which houses the *new* filter

	delete_flags: bool
	boolean flag for whether or not to delete an old observation.
	set True for the first occurrence of each observation time.
	for example:
	the V-band can be broken down into the g- and r-bands.
	when adding the g-band observation, we set delete_flags = True
	which deletes the old V-band observation.
	for the r-band observation, we set delete_flags = False
	since the old V-band observation has already been removed.
	'''

	# These magnitudes are reported using the VEGA magnitude system
	# As such, the new magnitudes are converted to AB magnitude values using the offset values in reference
	# m_AB - m_vega = offset
	# m_AB = offset + m_vega
	# Reference: https://www.astronomy.ohio-state.edu/martini.10/usefuldata.html

	offsets = {
		"g": -0.08,
		"r": 0.16,
		"i": 0.37,
		"z": 0.54,
		"y": 0.63,
		"J": 0.91,
		"H": 1.39,
		"K": 1.85}

	data = json.load(open(dfile), encoding="UTF-8")
	photometry = data[dfile.split('/')[-1][:-5]]["photometry"]
	## Each N added observations will shift the old observation indices by N-1 (the -1 is from removing the old observations), so we add counter
	counter = 1

	### TODO: HAVE THIS FUNCTION IDENTIFY THE OBSERVATIONS ON ITS OWN AND HANDLE E_MAGNITUDE AS IN ADJUST_FILTERS FUNCTION

	obs_times = np.array([float(photometry[entry]["time"]) for entry in range(len(photometry))])
	for i in range(len(times)):
		obs_idx = obs_idxs[i]
		old_photometry = photometry[obs_idx+counter-1]
		if delete_flags[i]:
			photometry = np.delete(photometry, obs_idx+counter-1).tolist()
			counter -= 1
		# Calculate magnitude in new filter
		mag_new, sigma_mag_new = redistribute_flux('filters/'+f1[i], 'filters/'+f2[i], old_obs[i])
		if convert_from_vega: mag_new += offsets[new_band[i]] # Vega -> AB conversion

		# Update dictionary entries with new band information
		new_obs_band = old_photometry.copy()
		new_obs_band["magnitude"] = str(round(mag_new, 1))
		new_obs_band["band"] = new_band[i]
		new_obs_band["instrument"] = instrument[i]
		new_obs_band["telescope"] = telescope[i]
		new_obs_band["system"] = "AB"
		new_obs_band["source"] = "converted from %s-band observation" % old_band[i]
		photometry = np.insert(photometry, obs_idx+counter, new_obs_band).tolist()
		counter += 1
		# Handle uncertainties
	
	photometry = adjust_filters(photometry)
	data[dfile.split('/')[-1][:-5]]["photometry"] = photometry
	with open('kne-parsed/%s_updated_obs.json' % dfile.split('/')[-1][:-5], 'w') as f:
		json.dump(data, f, ensure_ascii=True, indent=4)

def adjust_filters(photometry):
	
	filters = {
		"g": "g",
		"r": "r",
		"i": "i",
		"z": "z",
		"y": "y",
		"J": "J",
		"H": "H",
		"K": "K",
		"R": "r",
		"Ks": "K",
		"I": "i",
		"r'": "r",}

	for obs in photometry:
		# if there is a magnitude uncertainty, 
		if "e_magnitude" in obs.keys(): continue
		elif ("e_upper_magnitude" in obs.keys() and "e_lower_magnitude" in obs.keys()):
			obs["e_magnitude"] = str(np.mean([float(obs["e_lower_magnitude"]), float(obs["e_upper_magnitude"])]))
		elif obs["upperlimit"] == True:
			obs["e_magnitude"] = str(5)
	
	return photometry


# THIS MIGHT BE USELESS, HOLD ON TO IT FOR NOW JUST IN CASE
def filter_overlap(filter_orig, filter_updt):

	# load each of the filters
	wav1, filt1 = np.loadtxt(f'filters/{fmap[filter_orig]}', unpack=True)
	wav2, filt2 = np.loadtxt(f'filters/{fmap[filter_updt]}', unpack=True)

	xmin = min(wav1.min(), wav2.min())
	xmax = max(wav1.max(), wav2.max())

	dx = 0.1*(xmax-xmin)
	xmin -= dx
	xmax += dx
	x = np.linspace(xmin, xmax, int(1e3))

	spl1 = np.interp(x, wav1, filt1)
	spl2 = np.interp(x, wav2, filt2)

	# where do we get at least 1% transmission from each filter?
	idx1 = spl1 > 0.01
	idx2 = spl2 > 0.01
	idx = np.logical_and(idx1, idx2)

	if len(idx) > 0:
		return filter_updt
	else: return None


if __name__=="__main__":

	import argparse
	
	parser = argparse.ArgumentParser()
	parser.add_argument('GRBpath', type=str, help='Path to GRB json file')
	args = parser.parse_args()

	# Print out original observation sources (telescopes/instruments)
	obs_sources = get_obs_sources(args.GRBpath)
	print('Original observation sources')
	print(obs_sources)
	print('---')

	# Identify which LSST grizy / 2MASS JHK filters overlap with
	# original observation filters

	#updated_sources = find_overlap(args.GRBpath)

	#print('Unique bands which overlap with each original observation')
	#print(updated_sources)
	#print('---')

	# Redistribute flux from original observations into new filters
	
	#redistribute_flux(args.GRBpath)	
